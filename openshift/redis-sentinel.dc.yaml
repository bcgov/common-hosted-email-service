---
apiVersion: v1
kind: Template
metadata:
  annotations:
    description: Redis in Sentinel mode, with persistent storage.
    iconClass: icon-redis
    openshift.io/display-name: Redis Sentinel (Persistent)
    openshift.io/long-description: This template deploys a HA Redis Sentinel cluster with persistent storage.
    tags: redis
  name: ${NAME}-sentinel-template
labels:
  app: ${NAME}-${INSTANCE}
  app.kubernetes.io/component: redis
  app.kubernetes.io/instance: ${INSTANCE}
  app.kubernetes.io/name: redis
  app.kubernetes.io/managed-by: template
  app.kubernetes.io/part-of: ${NAME}-${INSTANCE}
  app.kubernetes.io/version: "6"
  template: ${NAME}-cluster-template
objects:
  # - apiVersion: networking.k8s.io/v1
  #   kind: NetworkPolicy
  #   metadata:
  #     name: "allow-redis-${INSTANCE}-to-redis-${INSTANCE}-cluster"
  #   spec:
  #     # Allow Redis pods to talk to its cluster
  #     ingress:
  #       - from:
  #           - podSelector:
  #               matchLabels:
  #                 app: ${NAME}-${INSTANCE}
  #                 statefulset: ${NAME}-${INSTANCE}
  #                 role: redis
  #         ports:
  #           - port: 6379
  #             protocol: TCP
  #           - port: 26379
  #             protocol: TCP
  #     podSelector:
  #       matchLabels:
  #         app: ${NAME}-${INSTANCE}
  #         statefulset: ${NAME}-${INSTANCE}
  #         role: redis
  - apiVersion: v1
    kind: ConfigMap
    metadata:
      name: ${NAME}-${INSTANCE}-config
    data:
      redis.conf: |
        dir "/data"
        port 6379
        masterauth replace-default-auth
        maxmemory 0
        maxmemory-policy volatile-lru
        min-replicas-max-lag 5
        min-replicas-to-write 1
        rdbchecksum yes
        rdbcompression yes
        repl-diskless-sync yes
        requirepass replace-default-auth
        save 900 1
        save 300 10
        save 60 10000
      sentinel.conf: |
        dir "/data"
        port 26379
            sentinel down-after-milliseconds ${INSTANCE} 10000
            sentinel failover-timeout ${INSTANCE} 180000
            maxclients 10000
            sentinel parallel-syncs ${INSTANCE} 5
        sentinel auth-pass ${INSTANCE} replace-default-auth
      init.sh: |
        echo "$(date) Start..."
        HOSTNAME="$(hostname)"
        INDEX="${HOSTNAME##*-}"
        SENTINEL_PORT=26379
        MASTER=''
        MASTER_GROUP="${INSTANCE}"
        QUORUM="2"
        REDIS_CONF=/data/conf/redis.conf
        REDIS_PORT=6379
        REDIS_TLS_PORT=
        SENTINEL_CONF=/data/conf/sentinel.conf
        SENTINEL_TLS_PORT=
        SERVICE=${NAME}-${INSTANCE}
        SENTINEL_TLS_REPLICATION_ENABLED=false
        REDIS_TLS_REPLICATION_ENABLED=false
        set -eu

        sentinel_get_master() {
        set +e
            if [ "$SENTINEL_PORT" -eq 0 ]; then
                redis-cli -h "${SERVICE}" -p "${SENTINEL_TLS_PORT}"   --tls --cacert /tls-certs/ca.crt --cert /tls-certs/redis.crt --key /tls-certs/redis.key sentinel get-master-addr-by-name "${MASTER_GROUP}" |\
                grep -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
            else
                redis-cli -h "${SERVICE}" -p "${SENTINEL_PORT}"  sentinel get-master-addr-by-name "${MASTER_GROUP}" |\
                grep -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
            fi
        set -e
        }

        sentinel_get_master_retry() {
            master=''
            retry=${1}
            sleep=3
            for i in $(seq 1 "${retry}"); do
                master=$(sentinel_get_master)
                if [ -n "${master}" ]; then
                    break
                fi
                sleep $((sleep + i))
            done
            echo "${master}"
        }

        identify_master() {
            echo "Identifying redis master (get-master-addr-by-name).."
            echo "  using sentinel (${NAME}-${INSTANCE}), sentinel group name (${INSTANCE})"
            echo "  $(date).."
            MASTER="$(sentinel_get_master_retry 3)"
            if [ -n "${MASTER}" ]; then
                echo "  $(date) Found redis master (${MASTER})"
            else
                echo "  $(date) Did not find redis master (${MASTER})"
            fi
        }

        sentinel_update() {
            echo "Updating sentinel config.."
            echo "  evaluating sentinel id (\${SENTINEL_ID_${INDEX}})"
            eval MY_SENTINEL_ID="\$SENTINEL_ID_${INDEX}"
            echo "  sentinel id (${MY_SENTINEL_ID}), sentinel grp (${MASTER_GROUP}), quorum (${QUORUM})"
            sed -i "1s/^/sentinel myid ${MY_SENTINEL_ID}\\n/" "${SENTINEL_CONF}"
            if [ "$SENTINEL_TLS_REPLICATION_ENABLED" = true ]; then
                echo "  redis master (${1}:${REDIS_TLS_PORT})"
                sed -i "2s/^/sentinel monitor ${MASTER_GROUP} ${1} ${REDIS_TLS_PORT} ${QUORUM} \\n/" "${SENTINEL_CONF}"
            else
                echo "  redis master (${1}:${REDIS_PORT})"
                sed -i "2s/^/sentinel monitor ${MASTER_GROUP} ${1} ${REDIS_PORT} ${QUORUM} \\n/" "${SENTINEL_CONF}"
            fi
            echo "sentinel announce-ip ${ANNOUNCE_IP}" >> ${SENTINEL_CONF}
            if [ "$SENTINEL_PORT" -eq 0 ]; then
                echo "  announce (${ANNOUNCE_IP}:${SENTINEL_TLS_PORT})"
                echo "sentinel announce-port ${SENTINEL_TLS_PORT}" >> ${SENTINEL_CONF}
            else
                echo "  announce (${ANNOUNCE_IP}:${SENTINEL_PORT})"
                echo "sentinel announce-port ${SENTINEL_PORT}" >> ${SENTINEL_CONF}
            fi
        }

        redis_update() {
            echo "Updating redis config.."
            if [ "$REDIS_TLS_REPLICATION_ENABLED" = true ]; then
                echo "  we are slave of redis master (${1}:${REDIS_TLS_PORT})"
                echo "slaveof ${1} ${REDIS_TLS_PORT}" >> "${REDIS_CONF}"
                echo "slave-announce-port ${REDIS_TLS_PORT}" >> ${REDIS_CONF}
            else
                echo "  we are slave of redis master (${1}:${REDIS_PORT})"
                echo "slaveof ${1} ${REDIS_PORT}" >> "${REDIS_CONF}"
                echo "slave-announce-port ${REDIS_PORT}" >> ${REDIS_CONF}
            fi
            echo "slave-announce-ip ${ANNOUNCE_IP}" >> ${REDIS_CONF}
        }

        copy_config() {
            echo "Copying default redis config.."
            echo "  to '${REDIS_CONF}'"
            cp /readonly-config/redis.conf "${REDIS_CONF}"
            echo "Copying default sentinel config.."
            echo "  to '${SENTINEL_CONF}'"
            cp /readonly-config/sentinel.conf "${SENTINEL_CONF}"
        }

        setup_defaults() {
            echo "Setting up defaults.."
            echo "  using statefulset index (${INDEX})"
            if [ "${INDEX}" = "0" ]; then
                echo "Setting this pod as master for redis and sentinel.."
                echo "  using announce (${ANNOUNCE_IP})"
                redis_update "${ANNOUNCE_IP}"
                sentinel_update "${ANNOUNCE_IP}"
                echo "  make sure ${ANNOUNCE_IP} is not a slave (slaveof no one)"
                sed -i "s/^.*slaveof.*//" "${REDIS_CONF}"
            else
                echo "Getting redis master ip.."
                echo "  blindly assuming (${SERVICE}-announce-0) or (${SERVICE}-server-0) are master"
                DEFAULT_MASTER="$(getent_hosts 0 | awk '{ print $1 }')"
                echo "  identified redis (may be redis master) ip (${DEFAULT_MASTER})"
                if [ -z "${DEFAULT_MASTER}" ]; then
                    echo "Error: Unable to resolve redis master (getent hosts)."
                    exit 1
                fi
                echo "Setting default slave config for redis and sentinel.."
                echo "  using master ip (${DEFAULT_MASTER})"
                redis_update "${DEFAULT_MASTER}"
                sentinel_update "${DEFAULT_MASTER}"
            fi
        }

        redis_ping() {
        set +e
            if [ "$REDIS_PORT" -eq 0 ]; then
                redis-cli -h "${MASTER}" -a "${AUTH}" -p "${REDIS_TLS_PORT}"  --tls --cacert /tls-certs/ca.crt --cert /tls-certs/redis.crt --key /tls-certs/redis.key ping
            else
                redis-cli -h "${MASTER}" -a "${AUTH}" -p "${REDIS_PORT}" ping
            fi
        set -e
        }

        redis_ping_retry() {
            ping=''
            retry=${1}
            sleep=3
            for i in $(seq 1 "${retry}"); do
                if [ "$(redis_ping)" = "PONG" ]; then
                    ping='PONG'
                    break
                fi
                sleep $((sleep + i))
                MASTER=$(sentinel_get_master)
            done
            echo "${ping}"
        }

        find_master() {
            echo "Verifying redis master.."
            if [ "$REDIS_PORT" -eq 0 ]; then
                echo "  ping (${MASTER}:${REDIS_TLS_PORT})"
            else
                echo "  ping (${MASTER}:${REDIS_PORT})"
            fi
            echo "  $(date).."
            if [ "$(redis_ping_retry 3)" != "PONG" ]; then
                echo "  $(date) Can't ping redis master (${MASTER})"
                echo "Attempting to force failover (sentinel failover).."

                if [ "$SENTINEL_PORT" -eq 0 ]; then
                    echo "  on sentinel (${SERVICE}:${SENTINEL_TLS_PORT}), sentinel grp (${MASTER_GROUP})"
                    echo "  $(date).."
                    if redis-cli -h "${SERVICE}" -p "${SENTINEL_TLS_PORT}"   --tls --cacert /tls-certs/ca.crt --cert /tls-certs/redis.crt --key /tls-certs/redis.key sentinel failover "${MASTER_GROUP}" | grep -q 'NOGOODSLAVE' ; then
                        echo "  $(date) Failover returned with 'NOGOODSLAVE'"
                        echo "Setting defaults for this pod.."
                        setup_defaults
                        return 0
                    fi
                else
                    echo "  on sentinel (${SERVICE}:${SENTINEL_PORT}), sentinel grp (${MASTER_GROUP})"
                    echo "  $(date).."
                    if redis-cli -h "${SERVICE}" -p "${SENTINEL_PORT}"  sentinel failover "${MASTER_GROUP}" | grep -q 'NOGOODSLAVE' ; then
                        echo "  $(date) Failover returned with 'NOGOODSLAVE'"
                        echo "Setting defaults for this pod.."
                        setup_defaults
                        return 0
                    fi
                fi

                echo "Hold on for 10sec"
                sleep 10
                echo "We should get redis master's ip now. Asking (get-master-addr-by-name).."
                if [ "$SENTINEL_PORT" -eq 0 ]; then
                    echo "  sentinel (${SERVICE}:${SENTINEL_TLS_PORT}), sentinel grp (${MASTER_GROUP})"
                else
                    echo "  sentinel (${SERVICE}:${SENTINEL_PORT}), sentinel grp (${MASTER_GROUP})"
                fi
                echo "  $(date).."
                MASTER="$(sentinel_get_master)"
                if [ "${MASTER}" ]; then
                    echo "  $(date) Found redis master (${MASTER})"
                    echo "Updating redis and sentinel config.."
                    sentinel_update "${MASTER}"
                    redis_update "${MASTER}"
                else
                    echo "$(date) Error: Could not failover, exiting..."
                    exit 1
                fi
            else
                echo "  $(date) Found reachable redis master (${MASTER})"
                echo "Updating redis and sentinel config.."
                sentinel_update "${MASTER}"
                redis_update "${MASTER}"
            fi
        }

        redis_ro_update() {
            echo "Updating read-only redis config.."
            echo "  redis.conf set 'replica-priority 0'"
            echo "replica-priority 0" >> ${REDIS_CONF}
        }

        getent_hosts() {
            index=${1:-${INDEX}}
            service="${SERVICE}-announce-${index}"
            pod="${SERVICE}-server-${index}"
            host=$(getent hosts "${service}")
            if [ -z "${host}" ]; then
                host=$(getent hosts "${pod}")
            fi
            echo "${host}"
        }

        mkdir -p /data/conf/

        echo "Initializing config.."
        copy_config

        # where is redis master
        identify_master

        echo "Identify announce ip for this pod.."
        echo "  using (${SERVICE}-announce-${INDEX}) or (${SERVICE}-server-${INDEX})"
        ANNOUNCE_IP=$(getent_hosts | awk '{ print $1 }')
        echo "  identified announce (${ANNOUNCE_IP})"
        if [ -z "${ANNOUNCE_IP}" ]; then
            "Error: Could not resolve the announce ip for this pod."
            exit 1
        elif [ "${MASTER}" ]; then
            find_master
        else
            setup_defaults
        fi

        if [ "${AUTH:-}" ]; then
            echo "Setting redis auth values.."
            ESCAPED_AUTH=$(echo "${AUTH}" | sed -e 's/[\/&]/\\&/g');
            sed -i "s/replace-default-auth/${ESCAPED_AUTH}/" "${REDIS_CONF}" "${SENTINEL_CONF}"
        fi

        if [ "${SENTINELAUTH:-}" ]; then
            echo "Setting sentinel auth values"
            ESCAPED_AUTH_SENTINEL=$(echo "$SENTINELAUTH" | sed -e 's/[\/&]/\\&/g');
            sed -i "s/replace-default-sentinel-auth/${ESCAPED_AUTH_SENTINEL}/" "$SENTINEL_CONF"
        fi

        echo "$(date) Ready..."
  - apiVersion: v1
    kind: ConfigMap
    metadata:
      name: ${NAME}-${INSTANCE}-health-config
    data:
      redis_liveness.sh: |
        response=$(
          redis-cli \
            -a "${AUTH}" --no-auth-warning \
            -h localhost \
            -p 6379 \
            ping
        )
        if [ "$response" != "PONG" ] && [ "${response:0:7}" != "LOADING" ] ; then
          echo "$response"
          exit 1
        fi
        echo "response=$response"
      redis_readiness.sh: |
        response=$(
          redis-cli \
            -a "${AUTH}" --no-auth-warning \
            -h localhost \
            -p 6379 \
            ping
        )
        if [ "$response" != "PONG" ] ; then
          echo "$response"
          exit 1
        fi
        echo "response=$response"
      sentinel_liveness.sh: |
        response=$(
          redis-cli \
            -a "${SENTINELAUTH}" --no-auth-warning \
            -h localhost \
            -p 26379 \
            ping
        )
        if [ "$response" != "PONG" ]; then
          echo "$response"
          exit 1
        fi
        echo "response=$response"
  - apiVersion: v1
    kind: Service
    metadata:
      name: ${NAME}-${INSTANCE}
    spec:
      type: ClusterIP
      clusterIP: None
      ports:
        - name: redis
          port: 6379
          protocol: TCP
          targetPort: 6379
        - name: sentinel
          port: 26379
          protocol: TCP
          targetPort: 26379
      selector:
        app: ${NAME}-${INSTANCE}
        statefulset: ${NAME}-${INSTANCE}
        role: redis
  - apiVersion: v1
    kind: Service
    metadata:
      name: ${NAME}-${INSTANCE}-announce-0
      annotations:
        service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
    spec:
      publishNotReadyAddresses: true
      type: ClusterIP
      ports:
        - name: redis
          port: 6379
          protocol: TCP
          targetPort: 6379
        - name: sentinel
          port: 26379
          protocol: TCP
          targetPort: 26379
      selector:
        app: ${NAME}-${INSTANCE}
        statefulset: ${NAME}-${INSTANCE}
        role: redis
        "statefulset.kubernetes.io/pod-name": ${NAME}-${INSTANCE}-0
  - apiVersion: v1
    kind: Service
    metadata:
      name: ${NAME}-${INSTANCE}-announce-1
      annotations:
        service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
    spec:
      publishNotReadyAddresses: true
      type: ClusterIP
      ports:
        - name: redis
          port: 6379
          protocol: TCP
          targetPort: 6379
        - name: sentinel
          port: 26379
          protocol: TCP
          targetPort: 26379
      selector:
        app: ${NAME}-${INSTANCE}
        statefulset: ${NAME}-${INSTANCE}
        role: redis
        "statefulset.kubernetes.io/pod-name": ${NAME}-${INSTANCE}-1
  - apiVersion: v1
    kind: Service
    metadata:
      name: ${NAME}-${INSTANCE}-announce-2
      annotations:
        service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
    spec:
      publishNotReadyAddresses: true
      type: ClusterIP
      ports:
        - name: redis
          port: 6379
          protocol: TCP
          targetPort: 6379
        - name: sentinel
          port: 26379
          protocol: TCP
          targetPort: 26379
      selector:
        app: ${NAME}-${INSTANCE}
        statefulset: ${NAME}-${INSTANCE}
        role: redis
        "statefulset.kubernetes.io/pod-name": ${NAME}-${INSTANCE}-2
  - apiVersion: apps/v1
    kind: StatefulSet
    metadata:
      name: ${NAME}-${INSTANCE}
    spec:
      podManagementPolicy: OrderedReady
      replicas: 3
      revisionHistoryLimit: 10
      selector:
        matchLabels:
          statefulset: ${NAME}-${INSTANCE}
      serviceName: ${NAME}-${INSTANCE}
      updateStrategy:
        type: RollingUpdate
      template:
        metadata:
          labels:
            app: ${NAME}-${INSTANCE}
            app.kubernetes.io/component: redis
            app.kubernetes.io/instance: ${INSTANCE}
            app.kubernetes.io/name: redis
            app.kubernetes.io/managed-by: template
            app.kubernetes.io/part-of: ${NAME}-${INSTANCE}
            app.kubernetes.io/version: "6"
            role: redis
            statefulset: ${NAME}-${INSTANCE}
        spec:
          affinity:
            podAntiAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                - labelSelector:
                    matchLabels:
                      app: ${NAME}-${INSTANCE}
                      statefulset: ${NAME}-${INSTANCE}
                      role: redis
                  topologyKey: kubernetes.io/hostname
          initContainers:
            - name: config-init
              image: ${IMAGE_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}
              imagePullPolicy: IfNotPresent
              resources: {}
              command:
                - sh
              args:
                - /readonly-config/init.sh
              env:
                - name: SENTINEL_ID_0
                  value: 4d1c322cd6a41bf54748997ebb29479ff7efa600
                - name: SENTINEL_ID_1
                  value: 40a7046999555c6e3d1e88d8adfa8f1ae0f700de
                - name: SENTINEL_ID_2
                  value: c1e39912ee5fe696e2d5cc914a0660fa859a231a
                - name: AUTH
                  valueFrom:
                    secretKeyRef:
                      key: password
                      name: ${NAME}-${INSTANCE}-secret
              volumeMounts:
                - name: config
                  mountPath: /readonly-config
                  readOnly: true
                - name: data
                  mountPath: /data
          containers:
            - name: redis
              image: ${IMAGE_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}
              imagePullPolicy: IfNotPresent
              command:
                - redis-server
              args:
                - /data/conf/redis.conf
              env:
                - name: AUTH
                  valueFrom:
                    secretKeyRef:
                      key: password
                      name: ${NAME}-${INSTANCE}-secret
                - name: REDISCLI_AUTH
                  valueFrom:
                    secretKeyRef:
                      key: password
                      name: ${NAME}-${INSTANCE}-secret
              lifecycle:
                preStop:
                  exec:
                    command:
                      - redis-cli
                    args:
                      - shutdown save
              livenessProbe:
                exec:
                  command:
                    - sh
                    - -c
                    - /health/redis_liveness.sh
                initialDelaySeconds: 30
                periodSeconds: 15
                timeoutSeconds: 15
                successThreshold: 1
                failureThreshold: 5
              ports:
                - name: redis
                  containerPort: 6379
              readinessProbe:
                exec:
                  command:
                    - sh
                    - -c
                    - /health/redis_readiness.sh
                initialDelaySeconds: 30
                periodSeconds: 15
                timeoutSeconds: 15
                successThreshold: 1
                failureThreshold: 5
              resources:
                requests:
                  cpu: ${CPU_REQUEST}
                  memory: ${MEMORY_REQUEST}
                limits:
                  cpu: ${CPU_LIMIT}
                  memory: ${MEMORY_LIMIT}
              volumeMounts:
                - mountPath: /data
                  name: data
                - mountPath: /health
                  name: health
            - name: sentinel
              image: ${IMAGE_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}
              imagePullPolicy: IfNotPresent
              command:
                - redis-sentinel
              args:
                - /data/conf/sentinel.conf
              env:
                - name: AUTH
                  valueFrom:
                    secretKeyRef:
                      key: password
                      name: ${NAME}-${INSTANCE}-secret
                - name: REDISCLI_AUTH
                  valueFrom:
                    secretKeyRef:
                      key: password
                      name: ${NAME}-${INSTANCE}-secret
              livenessProbe:
                exec:
                  command:
                    - sh
                    - -c
                    - /health/sentinel_liveness.sh
                initialDelaySeconds: 30
                periodSeconds: 15
                timeoutSeconds: 15
                successThreshold: 1
                failureThreshold: 5
              ports:
                - name: sentinel
                  containerPort: 26379
              resources:
                requests:
                  cpu: ${CPU_REQUEST}
                  memory: ${MEMORY_REQUEST}
                limits:
                  cpu: ${CPU_LIMIT}
                  memory: ${MEMORY_LIMIT}
              volumeMounts:
                - mountPath: /data
                  name: data
                - mountPath: /health
                  name: health
          volumes:
            - name: config
              configMap:
                name: ${NAME}-${INSTANCE}-config
            - name: health
              configMap:
                name: ${NAME}-${INSTANCE}-health-config
                defaultMode: 0755
      volumeClaimTemplates:
        - metadata:
            name: data
            labels:
              app: ${NAME}-${INSTANCE}
              statefulset: ${NAME}-${INSTANCE}
              role: redis
          spec:
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: ${PVC_SIZE}
          storageClassName: ${STORAGE_CLASS}
parameters:
  - name: NAME
    description: The name of the application for labelling all artifacts.
    displayName: Application Name
    required: true
    value: redis
  - name: INSTANCE
    description: The name of this instance of the application
    displayName: Application Instance Name
    required: true
  - name: IMAGE_REGISTRY
    description: The base docker registry
    displayName: Docker Image Registry
    required: true
    value: docker.io
  - name: IMAGE_NAME
    description: Redis Image Name
    displayName: Image Name
    required: true
    value: redis
  - name: IMAGE_TAG
    description: Redis Image Tag
    displayName: Image Tag
    required: true
    value: 6.0.9-alpine
  - name: CPU_REQUEST
    description: Starting amount of CPU the container can use.
    displayName: CPU Request
    required: true
    value: 25m
  - name: CPU_LIMIT
    description: Maximum amount of CPU the container can use.
    displayName: CPU Limit
    required: true
    value: 100m
  - name: MEMORY_REQUEST
    description: Starting amount of memory the container can use.
    displayName: Memory Request
    required: true
    value: 64Mi
  - name: MEMORY_LIMIT
    description: Maximum amount of memory the container can use.
    displayName: Memory Limit
    required: true
    value: 256Mi
  - name: PVC_SIZE
    description: The size of the persistent volume to create.
    displayName: Persistent Volume Size
    required: true
    value: 512Mi
  - name: STORAGE_CLASS
    description: The type of the persistent volume to create.
    displayName: Persistent Volume Class
    required: true
    value: netapp-file-standard
